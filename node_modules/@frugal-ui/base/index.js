"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Select = exports.ScrollArea = exports.RadioButton = exports.ProgressBar = exports.ProgressBarStates = exports.Popover = exports.Meter = exports.ListItem = exports.List = exports.ListStyles = exports.Link = exports.Label = exports.Input = exports.TimeInputCfg = exports.DateInputCfg = exports.NumberInputCfg = exports.TextInputCfg = exports.Icon = exports.HStack = exports.Header = exports.GroupContainer = exports.Form = exports.Div = exports.Container = exports.Checkbox = exports.ButtonGroup = exports.Button = exports.ButtonStyles = exports.Box = exports.AutoComplete = exports.Accordion = exports.Component = exports.ScreenSizes = exports.unwrapBindable = exports.unwrapValue = exports.ProxyState = exports.LocalStorageState = exports.ComputedState = exports.State = exports.BindableDummy = exports.BindableObject = exports.CheckSBModel = exports.ValueSBModel = exports.DataSelection = exports.CheckedTBModel = exports.ValueTBModel = exports.GenericTBModel = exports.IdentifiableObjectMap = exports.UUID = exports.buildInterface = void 0;
exports.TabView = exports.NavigationLink = exports.Stage = exports.GenericScene = exports.SceneTypes = exports.VStack = exports.VisualGroup = exports.Textarea = exports.Text = exports.Submit = exports.Spacer = exports.Slider = exports.Sheet = exports.Separator = exports.SelectingListItem = void 0;
require("material-icons/iconfont/round.css");
const css_property_names_1 = require("css-property-names");
require("./styles/base.css");
require("./styles/color.css");
require("./styles/fonts.css");
require("./styles/theme.css");
/*
 * MAIN
 */
function buildInterface(component) {
    document.body.appendChild(component);
}
exports.buildInterface = buildInterface;
/*
 * BASIC
 */
class UUID {
    constructor() {
        let uuid = '';
        const chars = '0123456789abcdef';
        for (let i = 0; i < 36; i++) {
            if (i === 8 || i === 13 || i === 18 || i === 23) {
                uuid += '-';
            }
            else if (i === 14) {
                uuid += '4';
            }
            else if (i === 19) {
                uuid += chars[(Math.random() * 4) | 8];
            }
            else {
                uuid += chars[(Math.random() * 16) | 0];
            }
        }
        this.value = uuid;
    }
    toString() {
        return this.value;
    }
}
exports.UUID = UUID;
class IdentifiableObjectMap {
    constructor() {
        this.map = new Map();
        this.get = (id) => {
            return this.map.get(id.toString());
        };
        this.set = (value) => {
            this.map.set(value.uuid.toString(), value);
        };
        this.remove = (value) => {
            this.map.delete(value.uuid.toString());
        };
        this.values = () => {
            return Array.from(this.map.values());
        };
        this.getSorted = (compareFn) => {
            return this.values().sort(compareFn);
        };
        this.forEach = (callbackFn) => {
            this.values().forEach(callbackFn);
        };
        this.clear = () => {
            this.map.clear();
        };
    }
    get length() {
        return this.values().length;
    }
}
exports.IdentifiableObjectMap = IdentifiableObjectMap;
/** Configure a binding for bi-directional changes. */
class GenericTBModel {
    constructor(configuration) {
        this.data = configuration.data;
        this.component = configuration.component;
        this.defaultValue = configuration.fallbackValue;
        this.changeEventName = configuration.changeEventName;
        this.getViewValue = configuration.getViewProperty;
        this.setViewValue = configuration.setViewProperty;
    }
}
exports.GenericTBModel = GenericTBModel;
/** Tightly binds a component's value. */
class ValueTBModel extends GenericTBModel {
    constructor(configuration) {
        super({
            data: configuration.data,
            component: configuration.component,
            fallbackValue: configuration.fallbackValue,
            changeEventName: 'input',
            getViewProperty: () => {
                var _a;
                return (_a = this.component.value) !== null && _a !== void 0 ? _a : this.defaultValue;
            },
            setViewProperty: (newValue) => {
                this.component.value = newValue;
            },
        });
    }
}
exports.ValueTBModel = ValueTBModel;
/** Tightly bind a component's 'checked' property. */
class CheckedTBModel extends ValueTBModel {
    constructor(configuration) {
        super({
            data: configuration.isChecked,
            component: configuration.component,
            fallbackValue: false,
        });
        this.changeEventName = 'change';
        this.getViewValue = () => {
            return this.component.checked;
        };
        this.setViewValue = (newValue) => {
            this.component.checked = newValue;
        };
        this.component = configuration.component;
    }
}
exports.CheckedTBModel = CheckedTBModel;
//selection
class DataSelection {
    constructor() {
        this.uuid = new UUID();
        this.selectedItems = new State([]);
    }
}
exports.DataSelection = DataSelection;
/** Add or remove ownValue on selectedItems */
class ValueSBModel {
    constructor(configuration) {
        this.isExclusive = false;
        this.getOwnIndex = () => {
            return this.selection.selectedItems.value.indexOf(this.ownValue);
        };
        this.getData = () => {
            return this.getOwnIndex() != -1;
        };
        this.setData = (isSelected) => {
            if (isSelected) {
                if (this.getOwnIndex() != -1)
                    return; //already selected
                if (this.isExclusive == true)
                    return (this.selection.selectedItems.value = [this.ownValue]);
                else
                    this.selection.selectedItems.value.push(this.ownValue);
            }
            else {
                if (this.getOwnIndex() == -1)
                    return; //already deselected
                this.selection.selectedItems.value.splice(this.getOwnIndex(), 1);
            }
            this.selection.selectedItems.triggerAll();
        };
        this.component = configuration.component;
        this.selection = configuration.selection;
        this.ownValue = configuration.ownValue;
        this.changeEventName = configuration.changeEventName;
        this.getView = configuration.getView;
        this.setView = configuration.setView;
        if (configuration.isExclusive)
            this.isExclusive = configuration.isExclusive;
    }
}
exports.ValueSBModel = ValueSBModel;
/** SelectionCfg for checkable components */
class CheckSBModel extends ValueSBModel {
    constructor(configuration) {
        super(Object.assign(Object.assign({}, configuration), { changeEventName: 'change', getView: () => {
                return this.component.checked;
            }, setView: (isSelected) => {
                this.component.checked = isSelected;
            } }));
        this.component = configuration.component;
    }
}
exports.CheckSBModel = CheckSBModel;
// BINDABLE
/** Can be bound, no further functionality. Should be extended by classes. */
class BindableObject {
    constructor(value) {
        this.uuid = new UUID();
        /* reactivity */
        this.triggerBinding = (binding) => { };
        this.triggerAll = () => { };
        this.addBinding = (binding) => { };
        this.removeBinding = (binding) => { };
        this._value = value;
    }
    /* basic */
    get value() {
        return this._value;
    }
    set value(newValue) {
        this._value = newValue;
        this.triggerAll();
    }
}
exports.BindableObject = BindableObject;
/**  Can be bound, working with one item. Used by unwrapBindable(). */
class BindableDummy extends BindableObject {
    constructor() {
        super(...arguments);
        /* reactivity */
        this.triggerBinding = () => {
            if (this.action)
                this.action(this._value);
        };
        this.triggerAll = () => {
            if (this.action)
                this.action(this._value);
        };
        this.addBinding = (binding) => {
            this.action = binding.action;
        };
    }
}
exports.BindableDummy = BindableDummy;
/** Reactive Variable. Bindings will be triggered on change. */
class State extends BindableObject {
    constructor() {
        super(...arguments);
        this.bindings = new Map();
        /* reactivity */
        this.triggerBinding = (binding) => {
            binding.action(this.value);
        };
        this.triggerAll = () => {
            this.bindings.forEach((action) => {
                action(this.value);
            });
        };
        this.addBinding = (binding) => {
            this.bindings.set(binding.uuid, binding.action);
        };
        this.removeBinding = (binding) => {
            this.bindings.delete(binding.uuid);
        };
    }
}
exports.State = State;
/** State binding another state. One-way. */
class ComputedState extends State {
    constructor(configuration) {
        super(configuration.initialValue);
        const binding = {
            uuid: new UUID(),
            action: () => configuration.compute(this),
        };
        configuration.statesToBind.forEach((bindable) => {
            bindable.addBinding(binding);
            bindable.triggerBinding(binding);
        });
    }
}
exports.ComputedState = ComputedState;
/** State linked to LocalStorage */
class LocalStorageState extends State {
    constructor(key, initialValue) {
        var _a;
        super((_a = localStorage.getItem(key)) !== null && _a !== void 0 ? _a : initialValue);
        this.addBinding({
            uuid: new UUID(),
            action: (newValue) => localStorage.setItem(key, newValue),
        });
    }
}
exports.LocalStorageState = LocalStorageState;
/** State binding and updating another state. Bi-directional. */
class ProxyState extends State {
    constructor(configuration) {
        super(configuration.convertFromOriginal(configuration.original.value));
        this.original = configuration.original;
        this.convertFromOriginal = configuration.convertFromOriginal;
        this.convertToOriginal = configuration.convertToOriginal;
        const binding = {
            uuid: new UUID(),
            action: () => {
                this._value = configuration.convertFromOriginal(this.original.value);
                this.triggerAll();
            },
        };
        this.original.addBinding(binding);
        this.original.triggerBinding(binding);
    }
    set value(newValue) {
        this._value = newValue;
        this.original.value = this.convertToOriginal(this.value);
    }
    get value() {
        return this._value;
    }
}
exports.ProxyState = ProxyState;
// HELPERS
/** Converts ValueObject to raw value. */
function unwrapValue(valueObject) {
    if (valueObject instanceof BindableObject)
        return valueObject.value;
    else
        return valueObject;
}
exports.unwrapValue = unwrapValue;
/** Converts ValueObject to BindableObject. */
function unwrapBindable(valueObject) {
    if (valueObject instanceof BindableObject)
        return valueObject;
    else
        return new BindableDummy(unwrapValue(valueObject));
}
exports.unwrapBindable = unwrapBindable;
var ScreenSizes;
(function (ScreenSizes) {
    ScreenSizes["Mobile"] = "screen-mobile";
    ScreenSizes["Tablet"] = "screen-tablet";
    ScreenSizes["Desktop"] = "screen-desktop";
})(ScreenSizes || (exports.ScreenSizes = ScreenSizes = {}));
function Component(tagName) {
    //create
    const component = document.createElement(tagName);
    //styles
    Object.keys(css_property_names_1.PrefixedCSSPropertyNames).forEach((componentProperty) => {
        const cssProperty = css_property_names_1.PrefixedCSSPropertyNames[componentProperty];
        component[componentProperty] = (value) => {
            component.setStyle(cssProperty, value);
            return component;
        };
    });
    //methods
    component.access = (fn) => {
        fn(component);
        return component;
    };
    component.focusOnCreate = () => {
        setTimeout(() => component.focus(), 100);
        return component;
    };
    component.focusOnChange = (state, matchingValue) => {
        component.createBinding(state, (newValue) => {
            // timeout needed for overlays
            if (newValue == matchingValue)
                setTimeout(() => component.focus(), 100);
        });
        return component;
    };
    component.setAccessibilityCurrentState = (state, shouldApply) => {
        component.createBinding(shouldApply, (shouldApply) => {
            component.setAttr('aria-current', shouldApply ? state : '');
        });
        return component;
    };
    component.setAccessibilityLabel = (label) => {
        component.setAttr('aria-label', label);
        return component;
    };
    component.setAccessibilityRole = (roleName) => {
        component.setAttr('role', roleName);
        return component;
    };
    component.allowKeyboardFocus = () => {
        component.setAttr('tabIndex', 0);
        return component;
    };
    //animation
    function prepareAnimation() {
        //get dimensions for animation
        const width = component.offsetWidth;
        const height = component.offsetHeight;
        component.style.setProperty('--element-width', `${width}px`);
        component.style.setProperty('--element-height', `${height}px`);
    }
    component.animateIn = (animationName = 'standard') => {
        const shouldAnimate = window.matchMedia('(prefers-reduced-motion)').matches == false;
        if (shouldAnimate) {
            //allow retreiving dimentions
            document.body.appendChild(component);
            prepareAnimation();
            component.remove();
            component
                .addToClass(`animation-${animationName}`)
                .addToClass('in-hidden-animation-state')
                .addToClass('animating-in');
            setTimeout(() => component.removeFromClass('in-hidden-animation-state'), 1);
            setTimeout(() => component.removeFromClass('animating-in'), 300);
        }
        return component;
    };
    component.animateOut = () => {
        return new Promise((resolve) => {
            function remove() {
                component.remove();
                resolve();
            }
            const shouldAnimate = window.matchMedia('(prefers-reduced-motion)').matches == false;
            if (shouldAnimate) {
                prepareAnimation();
                component
                    .addToClass('animating-out')
                    .addToClass('in-hidden-animation-state');
                setTimeout(() => remove(), 300);
            }
            else {
                remove();
            }
        });
    };
    //attributes
    component.setID = (id) => {
        component.id = id.toString();
        return component;
    };
    component.setAttr = (key, value = '') => {
        const bindable = unwrapBindable(value);
        component
            .createBinding(bindable, (newValue) => {
            component.setAttribute(key, newValue.toString());
        })
            .updateBinding(bindable);
        return component;
    };
    component.rmAttr = (key) => {
        component.removeAttribute(key);
        return component;
    };
    component.toggleAttr = (key, condition) => {
        const bindable = unwrapBindable(condition);
        component
            .createBinding(bindable, (newValue) => {
            if (newValue == true)
                component.setAttribute(key, '');
            else
                component.removeAttribute(key);
        })
            .updateBinding(bindable);
        return component;
    };
    component.resetClasses = () => {
        component.className = '';
        return component;
    };
    component.removeFromClass = (className) => {
        component.classList.remove(className);
        return component;
    };
    component.addToClass = (className) => {
        component.classList.add(className);
        return component;
    };
    component.addToClassConditionally = (className, condition) => {
        const bindable = unwrapBindable(condition);
        component
            .createBinding(bindable, (newValue) => {
            component.classList.toggle(className, newValue);
        })
            .updateBinding(bindable);
        return component;
    };
    component.setStyle = (property, value) => {
        component.style[property] = value.toString();
        return component;
    };
    //children
    component.addItems = (...children) => {
        children.forEach((child) => {
            component.appendChild(child);
        });
        return component;
    };
    component.addItemsBefore = (...children) => {
        children.forEach((child) => {
            component.insertBefore(child, component.firstChild);
        });
        return component;
    };
    component.clear = () => {
        component.innerHTML = '';
        return component;
    };
    component.setItems = (children) => {
        const bindable = unwrapBindable(children);
        component
            .createBinding(bindable, (children) => {
            component.clear().addItems(...children);
        })
            .updateBinding(bindable);
        return component;
    };
    //content
    component.setText = (text) => {
        const bindable = unwrapBindable(text);
        component
            .createBinding(bindable, (newValue) => {
            component.innerText = newValue.toString();
        })
            .updateBinding(bindable);
        return component;
    };
    component.setValue = (value) => {
        const bindable = unwrapBindable(value);
        component
            .createBinding(bindable, (newValue) => {
            component.value = newValue;
        })
            .updateBinding(bindable);
        return component;
    };
    component.setHTML = (text) => {
        const bindable = unwrapBindable(text);
        component
            .createBinding(bindable, (newValue) => {
            component.innerHTML = newValue;
        })
            .updateBinding(bindable);
        return component;
    };
    //events
    component.listen = (eventName, handler) => {
        component.addEventListener(eventName, handler);
        return component;
    };
    component.ignore = (eventName, handler) => {
        component.addEventListener(eventName, handler);
        return component;
    };
    component.registerKeyboardShortcuts = (...shortcuts) => {
        component.listen('keydown', (rawEvent) => {
            const ev = rawEvent;
            A: for (const shortcut of shortcuts) {
                //make sure all modifiers are pressed
                if (shortcut.modifiers)
                    for (const modifier of shortcut.modifiers) {
                        if (modifier == 'commandOrControl') {
                            if (ev.ctrlKey == false && ev.metaKey == false)
                                continue A;
                        }
                        else if (ev[modifier] == false) {
                            continue A;
                        }
                    }
                if (ev.key == shortcut.key) {
                    shortcut.action(ev);
                }
            }
        });
        return component;
    };
    //navigation
    component.hideConditionally = (isHidden) => {
        component.toggleAttr('hidden', isHidden);
        component.setAttr('aria-hidden', isHidden);
        return component;
    };
    component.setVisibleIfMatch = (a, b) => {
        const bindableA = unwrapBindable(a);
        const bindableB = unwrapBindable(b);
        function update() {
            component.hideConditionally(bindableA.value != bindableB.value);
        }
        component
            .createBinding(bindableA, update)
            .updateBinding(bindableA)
            .createBinding(bindableB, update)
            .updateBinding(bindableB);
        return component;
    };
    //state
    component.bindings = new Map();
    component.createBinding = (bindable, action) => {
        const binding = {
            uuid: new UUID(),
            action,
        };
        bindable.addBinding(binding);
        component.bindings.set(bindable.uuid.toString(), binding);
        return component;
    };
    component.createTightBinding = (model) => {
        component
            .createBinding(model.data, (newValue) => {
            model.setViewValue(newValue);
        })
            .updateBinding(model.data)
            .listen(model.changeEventName, () => {
            model.data.value = model.getViewValue();
        });
        return component;
    };
    component.createSelectionBinding = (model) => {
        component
            .createBinding(model.selection.selectedItems, () => {
            const isSelected = model.getOwnIndex() != -1;
            model.setView(isSelected);
        })
            .updateBinding(model.selection.selectedItems)
            .listen(model.changeEventName, () => {
            const isSelectedInView = model.getView();
            model.setData(isSelectedInView);
        });
        return component;
    };
    component.removeBinding = (bindable) => {
        const binding = component.bindings.get(bindable.uuid.toString());
        if (!binding) {
            console.error(`Failed to unbind ${bindable.uuid.toString()} but bindable is unknown.`);
            return component;
        }
        bindable.removeBinding(binding);
        component.bindings.delete(bindable.uuid.toString());
        return component;
    };
    component.updateBinding = (bindable) => {
        const binding = component.bindings.get(bindable.uuid.toString());
        if (!binding) {
            console.error(`Failed to update on bindable ${bindable.uuid.toString()} but bindable is unknown.`);
            return component;
        }
        bindable.triggerBinding(binding);
        return component;
    };
    //style
    component.forceDefaultStyles = () => {
        component.addToClass('forcing-default-styles');
        return component;
    };
    component.hideOnScreenSize = (size) => {
        component.addToClass('hides-responsively').addToClass(size);
        return component;
    };
    component.useDefaultPadding = () => {
        component.addToClass('using-default-padding');
        return component;
    };
    component.useDefaultSpacing = () => {
        component.cssGap('var(--gap)');
        return component;
    };
    component.useMutedColor = () => {
        component.cssOpacity(0.6);
        return component;
    };
    return component.addToClass('frugal-ui-components');
}
exports.Component = Component;
// SPECIFIC
/* Accordion */
function Accordion(label, ...children) {
    return Container('details', Text(label, 'summary'), ...children);
}
exports.Accordion = Accordion;
/* AutoComplete */
function AutoComplete(optionData, input) {
    const uuid = new UUID();
    const optionViews = new ComputedState({
        statesToBind: [optionData],
        initialValue: [],
        compute: (self) => {
            self.value = optionData.value.map((option) => Text(option, 'option'));
        },
    });
    return Div(Component('datalist').setID(uuid).setItems(optionViews), input.setAttr('list', uuid));
}
exports.AutoComplete = AutoComplete;
/* Box */
function Box(...children) {
    return Div(...children).addToClass('boxes');
}
exports.Box = Box;
/* Button */
var ButtonStyles;
(function (ButtonStyles) {
    ButtonStyles["Transparent"] = "buttons-transparent";
    ButtonStyles["Normal"] = "buttons-normal";
    ButtonStyles["Primary"] = "buttons-primary";
    ButtonStyles["Destructive"] = "buttons-destructive";
    ButtonStyles["Pressed"] = "buttons-pressed";
})(ButtonStyles || (exports.ButtonStyles = ButtonStyles = {}));
function Button(configuration) {
    var _a, _b, _c;
    return Component('button')
        .addItems(Icon((_a = configuration.iconName) !== null && _a !== void 0 ? _a : ''), Text((_b = configuration.text) !== null && _b !== void 0 ? _b : '').addToClass('button-texts'))
        .setAttr('aria-label', configuration.accessibilityLabel)
        .addToClass('buttons')
        .addToClass((_c = configuration.style) !== null && _c !== void 0 ? _c : ButtonStyles.Normal)
        .listen('click', (e) => {
        e.stopPropagation();
        configuration.action(e);
    });
}
exports.Button = Button;
/* ButtonGroup */
function ButtonGroup(...buttons) {
    return Div(...buttons).addToClass('button-groups');
}
exports.ButtonGroup = ButtonGroup;
function Checkbox(configuration) {
    return Text(configuration.label, 'label').addItemsBefore(Input({
        type: 'checkbox',
        fallbackValue: undefined,
        value: undefined,
        placeholder: undefined,
        toValueType: (inputValue) => inputValue,
        valueToString: (inputValue) => inputValue,
    })
        .addToClass('checkable-items')
        .access((self) => {
        self.createTightBinding(new CheckedTBModel({
            isChecked: configuration.isChecked,
            component: self,
        }));
        if (configuration.isIndeterminate != undefined)
            self.createTightBinding(new GenericTBModel({
                component: self,
                data: configuration.isIndeterminate,
                fallbackValue: false,
                changeEventName: 'change',
                getViewProperty: () => self.indeterminate,
                setViewProperty: (newValue) => (self.indeterminate = newValue),
            }));
    }));
}
exports.Checkbox = Checkbox;
/* Container */
function Container(tagName, ...children) {
    return Component(tagName).addItems(...children);
}
exports.Container = Container;
/* Div */
function Div(...children) {
    return Container('div', ...children);
}
exports.Div = Div;
function Form(configuration, ...children) {
    return Container('form', ...children)
        .setAttr('action', configuration.action)
        .setAttr('method', configuration.method);
}
exports.Form = Form;
/* GroupContainer */
function GroupContainer(label, ...children) {
    return VStack(Text(label, 'h5').useMutedColor(), VStack(...children)
        .cssFlex(0)
        .cssAlignItems('start')
        .cssJustifyContent('start'))
        .useDefaultSpacing()
        .cssJustifyContent('start')
        .cssMarginTop('1rem')
        .cssFlex(0);
}
exports.GroupContainer = GroupContainer;
function Header(configuration, ...actions) {
    return HStack()
        .access((self) => {
        if (configuration.parentScene)
            self.addItems(Button({
                style: ButtonStyles.Transparent,
                iconName: 'chevron_left',
                accessibilityLabel: 'go back',
                action: configuration.parentScene.close,
            }).access((self) => {
                if (!configuration.forceShowBackButton == true)
                    self.hideOnScreenSize(ScreenSizes.Desktop);
            }));
    })
        .addItems(Text(configuration.text, 'h5').access((self) => {
        if (configuration.hideTextOnMobile == true)
            self.hideOnScreenSize(ScreenSizes.Mobile);
    }), Spacer(), ...actions)
        .cssFlex(0)
        .useDefaultSpacing()
        .addToClass('headers');
}
exports.Header = Header;
/* HStack */
function HStack(...children) {
    return Div(...children).addToClass('stacks-horizontal');
}
exports.HStack = HStack;
/* Icon */
function Icon(iconName) {
    return Text(iconName)
        .addToClass('icons')
        .addToClass('material-icons-round')
        .setAttr('translate', 'no');
}
exports.Icon = Icon;
class TextInputCfg {
    constructor(value, placeholder = '') {
        this.type = 'text';
        this.toValueType = (inputValue) => inputValue;
        this.valueToString = (value) => value;
        this.fallbackValue = value.value;
        this.value = value;
        this.placeholder = placeholder;
    }
}
exports.TextInputCfg = TextInputCfg;
class NumberInputCfg {
    constructor(value, placeholder = '') {
        this.type = 'number';
        this.toValueType = (inputValue) => parseFloat(inputValue);
        this.valueToString = (value) => value.toString();
        this.fallbackValue = value.value;
        this.value = value;
        this.placeholder = placeholder;
    }
}
exports.NumberInputCfg = NumberInputCfg;
class DateInputCfg {
    constructor(value, placeholder = '') {
        this.type = 'date';
        this.toValueType = (inputValue) => new Date(inputValue);
        this.valueToString = (value) => {
            const day = value.toLocaleString('en-US', {
                day: '2-digit',
            });
            const month = value.toLocaleString('en-US', {
                month: '2-digit',
            });
            const year = value.getFullYear();
            return `${year}-${month}-${day}`;
        };
        this.fallbackValue = value.value;
        this.value = value;
        this.placeholder = placeholder;
    }
}
exports.DateInputCfg = DateInputCfg;
class TimeInputCfg extends DateInputCfg {
    constructor() {
        super(...arguments);
        this.type = 'time';
        this.toValueType = (inputValue) => {
            const date = new Date();
            const [hours, minutes] = inputValue.split(':');
            date.setHours(parseInt(hours));
            date.setMinutes(parseInt(minutes));
            return date;
        };
        this.valueToString = (value) => {
            const hour = value.getHours().toString().padStart(2, '0');
            const minute = value.getMinutes().toString().padStart(2, '0');
            return `${hour}:${minute}`;
        };
    }
}
exports.TimeInputCfg = TimeInputCfg;
function Input(configuration) {
    return Component('input')
        .addToClass('inputs')
        .access((self) => {
        var _a;
        self.setAttr('type', configuration.type).setAttr('placeholder', (_a = configuration.placeholder) !== null && _a !== void 0 ? _a : '');
        if (configuration.value != undefined &&
            configuration.fallbackValue != undefined)
            self.createTightBinding({
                data: configuration.value,
                component: self,
                defaultValue: configuration.fallbackValue,
                changeEventName: 'input',
                getViewValue: () => configuration.toValueType(self.value),
                setViewValue: (newValue) => (self.value = configuration.valueToString(newValue)),
            });
    });
}
exports.Input = Input;
/* Label */
function Label(labelText, labeledItem) {
    return Component('label')
        .setText(labelText)
        .addItems(labeledItem)
        .addToClass('labels');
}
exports.Label = Label;
/* Link */
function Link(label, href) {
    return Text(label, 'a').setAttr('href', href);
}
exports.Link = Link;
/* List */
var ListStyles;
(function (ListStyles) {
    ListStyles["Normal"] = "list";
    ListStyles["Group"] = "list";
    ListStyles["Box"] = "listbox";
})(ListStyles || (exports.ListStyles = ListStyles = {}));
function List(configuration, compute) {
    var _a;
    // Sorting
    let draggedComponent = undefined;
    let draggedData = undefined;
    let dragStartTimeout = undefined;
    const compareFn = (a, b) => a.index.value - b.index.value;
    function cleanIndices() {
        configuration.listData.value
            .values()
            .sort(compareFn)
            .forEach((item, i) => (item.index.value = i));
    }
    function startDrag(e, data, component) {
        document.body.addEventListener('mouseup', stopDrag);
        document.body.addEventListener('touchend', stopDrag);
        dragStartTimeout = setTimeout(() => {
            draggedData = data;
            draggedComponent = component.addToClass('dragging');
        }, 200);
    }
    function handleDragMove(e) {
        if (draggedData == undefined)
            return;
        function getCoordinate(e, axis) {
            if ('touches' in e) {
                return e.touches[0][axis];
            }
            else if (axis in e) {
                return e[axis];
            }
            //fallback
            return 0;
        }
        const elementUnderCursor = document.elementFromPoint(getCoordinate(e, 'clientX'), getCoordinate(e, 'clientY'));
        if (elementUnderCursor == null)
            return;
        const data = configuration.listData.value.get(elementUnderCursor.id);
        if (data == null)
            return;
        const ownIndex = data.index.value;
        const currentDraggedIndex = draggedData.index.value;
        draggedData.index.value = ownIndex;
        data.index.value = currentDraggedIndex;
    }
    function stopDrag() {
        if (dragStartTimeout)
            clearTimeout(dragStartTimeout);
        if (draggedData == undefined)
            return;
        document.body.removeEventListener('mouseup', stopDrag);
        document.body.removeEventListener('touchend', stopDrag);
        draggedData = undefined;
        cleanIndices();
        if (draggedComponent == undefined)
            return;
        draggedComponent.removeFromClass('dragging');
        draggedComponent = undefined;
    }
    // Main
    const style = (_a = configuration.style) !== null && _a !== void 0 ? _a : ListStyles.Normal;
    return VStack()
        .setAccessibilityRole(style)
        .listen('touchmove', (e) => handleDragMove(e))
        .listen('mousemove', (e) => handleDragMove(e))
        .access((listView) => {
        if (style == ListStyles.Box)
            listView.addToClass('boxes');
        if (style == ListStyles.Group)
            listView.addToClass('visual-groups');
        listView
            .createBinding(configuration.listData, (listData) => {
            function removeItemView(itemView) {
                var _a;
                const removeFn = (_a = itemView.animateOut) !== null && _a !== void 0 ? _a : itemView.remove;
                removeFn();
            }
            //add new items
            configuration.listData.value
                .getSorted(compareFn)
                .forEach((itemData, i) => {
                const oldItemView = document.getElementById(itemData.uuid.toString());
                //already exists
                if (oldItemView != null)
                    return;
                const indexBindable = unwrapBindable(itemData.index);
                configuration.listData.addBinding({
                    uuid: new UUID(),
                    action: () => indexBindable.triggerAll(),
                });
                const newItemView = compute(itemData)
                    .setID(itemData.uuid)
                    .access((self) => {
                    self.createBinding(indexBindable, (newIndex) => {
                        self.cssOrder(newIndex.toString());
                        self.addToClassConditionally('first-item', newIndex == 0);
                        self.addToClassConditionally('last-item', newIndex == listData.length - 1);
                    }).updateBinding(indexBindable);
                    if (configuration.sortable == true)
                        self.addToClass('draggable-items')
                            .addToClass('rearrangable-items')
                            .listen('mousedown', (e) => startDrag(e, itemData, self))
                            .listen('touchstart', (e) => startDrag(e, itemData, self));
                })
                    .animateIn('list-item');
                listView.append(newItemView);
            });
            //remove deleted items
            Array.from(listView.children).forEach((itemView) => {
                const matchingDataEntry = listData.get(itemView.id);
                if (matchingDataEntry != undefined)
                    return; //data entry still exists
                removeItemView(itemView);
            });
        })
            .updateBinding(configuration.listData)
            .addToClass('ordered-containers');
    });
}
exports.List = List;
/* ListItem */
function ListItem(...children) {
    return Div(...children)
        .addToClass('list-items')
        .setAccessibilityRole('listitem')
        .animateIn('list-item');
}
exports.ListItem = ListItem;
function Meter(value, options = {}) {
    var _a, _b, _c, _d;
    const min = (_a = options.min) !== null && _a !== void 0 ? _a : 0;
    const max = (_b = options.max) !== null && _b !== void 0 ? _b : 1;
    const low = (_c = options.low) !== null && _c !== void 0 ? _c : min;
    const high = (_d = options.high) !== null && _d !== void 0 ? _d : max;
    return Component('meter')
        .setValue(value)
        .setAttr('min', min)
        .setAttr('max', max)
        .setAttr('low', low)
        .setAttr('high', high);
}
exports.Meter = Meter;
function Popover(configuration) {
    // Alignment
    const PADDING = '.5rem';
    resetPosition();
    const rectOfToggle = () => configuration.toggle.getBoundingClientRect();
    let rectOfContent = () => configuration.content.getBoundingClientRect();
    let rectOfWindow = () => document.body.getBoundingClientRect();
    function checkIsOK() {
        const isOK = !(rectOfContent().top < rectOfWindow().top ||
            rectOfContent().left < rectOfWindow().left ||
            rectOfContent().right > rectOfWindow().right ||
            rectOfContent().bottom > rectOfWindow().bottom);
        return isOK;
    }
    function resetPosition() {
        configuration.content
            .cssTop('unset')
            .cssLeft('unset')
            .cssRight('unset')
            .cssBottom('unset')
            .cssMaxHeight('unset')
            .cssMaxWidth('unset');
    }
    function alignToRightFromLeftEdge() {
        configuration.content.cssLeft(`${rectOfToggle().left}px`);
    }
    function alignToRightFromRightEdge() {
        configuration.content.cssLeft(`${rectOfToggle().right}px`);
    }
    function alignToLeftFromLeftEdge() {
        configuration.content.cssLeft(`${rectOfToggle().left - rectOfContent().width}px`);
    }
    function alignToLeftFromRightEdge() {
        configuration.content.cssLeft(`${rectOfToggle().right - rectOfContent().width}px`);
    }
    function tryXAxisFix() {
        alignToRightFromLeftEdge();
        if (checkIsOK() == true)
            return;
        alignToLeftFromRightEdge();
    }
    function alignY() {
        //down
        resetPosition();
        configuration.content.cssTop(`${rectOfToggle().bottom}px`);
        if (checkIsOK() == true)
            return;
        tryXAxisFix();
        if (checkIsOK() == true)
            return;
        //up
        resetPosition();
        configuration.content.cssTop(`${rectOfToggle().top - rectOfContent().height}px`);
        if (checkIsOK() == true)
            return;
        tryXAxisFix();
    }
    function alignX() {
        //to left
        resetPosition();
        alignToRightFromRightEdge();
        if (checkIsOK() == true)
            return;
        //to right
        resetPosition();
        alignToLeftFromLeftEdge();
    }
    function applyFallbackAlignment() {
        resetPosition();
        configuration.content
            .cssBottom(PADDING)
            .cssMaxHeight(`calc(100% - 2*${PADDING})`)
            .cssMaxWidth(`calc(100% - 2*${PADDING})`)
            .cssLeft(PADDING)
            .cssRight(PADDING);
    }
    function updateContentPosition() {
        if (configuration.isOpen.value == false)
            return;
        const alignmentFunctions = [alignY, alignX, applyFallbackAlignment];
        for (let i = 0; i < alignmentFunctions.length; i++) {
            alignmentFunctions[i]();
            if (checkIsOK() == true)
                return;
        }
    }
    // Reactivity
    function closePopover() {
        configuration.isOpen.value = false;
    }
    configuration.isOpen.addBinding({
        uuid: new UUID(),
        action: (wasOpened) => {
            if (wasOpened) {
                document.body.addEventListener('click', closePopover);
                updateContentPosition();
            }
            else {
                document.body.removeEventListener('click', closePopover);
            }
        },
    });
    // Main
    return Div(configuration.toggle, configuration.content
        .addToClass('popover-contents')
        .setAttr('aria-modal', 'true')
        .setAccessibilityLabel(configuration.accessibilityLabel)
        .allowKeyboardFocus()
        .focusOnChange(configuration.isOpen, true))
        .listen('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
    })
        .addToClass('popover-containers')
        .toggleAttr('open', configuration.isOpen);
}
exports.Popover = Popover;
/* ProgressBar */
var ProgressBarStates;
(function (ProgressBarStates) {
    ProgressBarStates[ProgressBarStates["Normal"] = 0] = "Normal";
    ProgressBarStates[ProgressBarStates["Indeterminate"] = 1] = "Indeterminate";
})(ProgressBarStates || (exports.ProgressBarStates = ProgressBarStates = {}));
function ProgressBar(value, state) {
    return Component('progress')
        .setValue(value)
        .access((self) => {
        if (state)
            self.createBinding(state, (state) => {
                const isIndeterminate = state == ProgressBarStates.Indeterminate;
                if (isIndeterminate)
                    self.rmAttr('value');
                else
                    self.value = value.value;
            }).updateBinding(state);
    });
}
exports.ProgressBar = ProgressBar;
function RadioButton(configuration) {
    return Text(configuration.label, 'label').addItemsBefore(Input({
        type: 'radio',
        fallbackValue: undefined,
        value: undefined,
        placeholder: undefined,
        toValueType: (inputValue) => inputValue,
        valueToString: (inputValue) => inputValue,
    })
        .access((self) => self.createSelectionBinding(new CheckSBModel({
        selection: configuration.selectionCfg,
        component: self,
        ownValue: configuration.value,
        isExclusive: true,
    })))
        .setAttr('name', configuration.selectionCfg.uuid));
}
exports.RadioButton = RadioButton;
/* ScrollArea */
function ScrollArea(...children) {
    return Div(...children).addToClass('scroll-areas');
}
exports.ScrollArea = ScrollArea;
function Select(value, options) {
    const optionViews = new ComputedState({
        statesToBind: [options],
        initialValue: [],
        compute: (self) => {
            self.value = options.value.map((option) => Text(option.label, 'option').setValue(option.value));
        },
    });
    return Component('select')
        .setItems(optionViews)
        .addToClass('selects')
        .access((self) => self.createTightBinding(new ValueTBModel({
        component: self,
        data: value,
        fallbackValue: '',
    })));
}
exports.Select = Select;
function SelectingListItem(configuration, ...children) {
    return ListItem(...children)
        .setAccessibilityRole('option')
        .access((self) => {
        var _a;
        const bindingModel = new ValueSBModel({
            component: self,
            selection: configuration.selection,
            getView: () => {
                return self.getAttribute('aria-selected') == 'true';
            },
            setView: (isSelected) => {
                self.setAttr('aria-selected', isSelected);
            },
            isExclusive: (_a = configuration.isExclusive) !== null && _a !== void 0 ? _a : true,
            ownValue: configuration.ownValue,
            changeEventName: 'click',
        });
        self.createSelectionBinding(bindingModel);
        self.listen('click', () => {
            const isChecked = configuration.isExclusive == true
                ? !bindingModel.getView()
                : true;
            bindingModel.setData(isChecked);
        });
    });
}
exports.SelectingListItem = SelectingListItem;
/* Separator */
function Separator() {
    return Component('hr').addToClass('separators');
}
exports.Separator = Separator;
function Sheet(configuration, ...children) {
    return Container('dialog', Div(...children)
        .addToClass('sheet-contents')
        .listen('click', (e) => e.stopPropagation())
        .setAccessibilityLabel(configuration.accessibilityLabel)
        .allowKeyboardFocus()
        .focusOnChange(configuration.isOpen, true))
        .addToClass('sheet-containers')
        .toggleAttr('open', configuration.isOpen)
        .listen('click', () => {
        configuration.isOpen.value = false;
    });
}
exports.Sheet = Sheet;
function Slider(value, options = {}) {
    return Input({
        type: 'range',
        fallbackValue: 0,
        value,
        placeholder: undefined,
        toValueType: (inputValue) => parseInt(inputValue),
        valueToString: (inputValue) => inputValue.toString(),
    }).access((self) => {
        var _a, _b, _c;
        return self
            .setAttr('min', (_a = options.min) !== null && _a !== void 0 ? _a : 0)
            .setAttr('max', (_b = options.max) !== null && _b !== void 0 ? _b : 100)
            .setAttr('step', (_c = options.step) !== null && _c !== void 0 ? _c : 1);
    });
}
exports.Slider = Slider;
/* Spacer */
function Spacer() {
    return Div().addToClass('spacers');
}
exports.Spacer = Spacer;
/* Submit */
function Submit(text) {
    return Component('input')
        .addToClass('submits')
        .setAttr('value', text)
        .setAttr('type', 'submit');
}
exports.Submit = Submit;
/* Text */
function Text(value, tagName = 'span') {
    return Component(tagName).setText(value);
}
exports.Text = Text;
/* Textarea */
function Textarea(value, placeholder) {
    return Component('textarea')
        .addToClass('textareas')
        .access((self) => self
        .createTightBinding(new ValueTBModel({
        component: self,
        data: value,
        fallbackValue: '',
    }))
        .setAttr('placeholder', placeholder));
}
exports.Textarea = Textarea;
/* VisualGroup */
function VisualGroup(...children) {
    return VStack(...children).addToClass('visual-groups');
}
exports.VisualGroup = VisualGroup;
/* VStack */
function VStack(...children) {
    return Div(...children).addToClass('stacks-vertical');
}
exports.VStack = VStack;
/*
 * NAVIGATION
 */
/* STAGE-BASED */
/* Scene */
var SceneTypes;
(function (SceneTypes) {
    SceneTypes["Column"] = "scenes-column";
    SceneTypes["Content"] = "scenes-content";
    SceneTypes["Full"] = "scenes-full";
    SceneTypes["Navigation"] = "scenes-navigation";
})(SceneTypes || (exports.SceneTypes = SceneTypes = {}));
class GenericScene {
    constructor(depth, stage, data) {
        this.linkSelection = new DataSelection();
        this.type = SceneTypes.Full;
        this.close = () => {
            this.stage.goBackTo(this.depth - 1);
        };
        this.depth = depth;
        this.stage = stage;
        this.view = this.generateView(data);
        this.stage.depth.addBinding({
            uuid: new UUID(),
            action: (stageDepth) => {
                if (stageDepth > depth + 1)
                    return; //has child scenes
                this.linkSelection.selectedItems.value = [];
            },
        });
    }
    generateView(data) {
        var _a;
        const main = Div(this.draw(data))
            .addToClass('scenes')
            .addToClass(this.type)
            .animateIn('scene')
            .setAccessibilityLabel((_a = this.accessibilityLabel) !== null && _a !== void 0 ? _a : '')
            .allowKeyboardFocus()
            .focusOnCreate();
        if (this.accessibilityLabel == undefined)
            console.warn('Scene does not have an accessibilityLabel.', this);
        return main;
    }
    draw(data) {
        return Text('Hello, world!');
    }
    setup(data) { }
    get isOpen() {
        if (!this.view)
            return false;
        return this.view.parentNode != null;
    }
}
exports.GenericScene = GenericScene;
function Stage(initialScene, initialSceneData) {
    return Div().addToClass('stages').access((self) => {
        let persistingChildren = [];
        function getPersistingChildren() {
            persistingChildren = Array.from(self.children).filter((child) => !child.classList.contains('animating-out'));
            return persistingChildren;
        }
        function getDepth() {
            return getPersistingChildren().length;
        }
        function updateDepth() {
            const depth = getDepth();
            self.depth.value = depth;
        }
        self.depth = new State(0);
        self.addScene = (Scene, data, depth = getDepth()) => {
            const scene = new Scene(depth, self, data);
            self.addItems(scene.view);
            scene.setup(data);
            scene.view.scrollIntoView();
            return self;
        };
        self.replaceScene = (Scene, data, depth) => __awaiter(this, void 0, void 0, function* () {
            yield self.goBackTo(depth - 1, false);
            self.addScene(Scene, data, depth);
            updateDepth();
            return self;
        });
        self.goBackTo = (depth, shouldUpdate = true) => __awaiter(this, void 0, void 0, function* () {
            while (getPersistingChildren().length > depth + 1) {
                const child = persistingChildren[persistingChildren.length - 1];
                const isColumnScene = child.classList.contains(SceneTypes.Column);
                if (child.animateOut && !isColumnScene)
                    yield child.animateOut();
                else
                    child.remove();
            }
            if (shouldUpdate)
                updateDepth();
            return self;
        });
        self.addScene(initialScene, initialSceneData);
    });
}
exports.Stage = Stage;
function NavigationLink(configuration, ...children) {
    const stage = configuration.parentScene.stage;
    const depth = configuration.parentScene.depth;
    const uuid = new UUID();
    function openScene() {
        stage.replaceScene(configuration.destination, configuration.data, depth + 1);
    }
    if (configuration.initiallySelected == true) {
        configuration.parentScene.linkSelection.selectedItems.value = [uuid];
    }
    const isSelected = new ComputedState({
        statesToBind: [configuration.parentScene.linkSelection.selectedItems],
        initialValue: false,
        compute(self) {
            self.value =
                configuration.parentScene.linkSelection.selectedItems.value.indexOf(uuid) > -1;
        },
    });
    return SelectingListItem({
        ownValue: uuid,
        selection: configuration.parentScene.linkSelection,
    }, HStack(...children), Spacer(), Icon('chevron_right').cssOpacity(0.6))
        .addToClass('navigation-links')
        .setAccessibilityRole('link')
        .setAccessibilityLabel(configuration.accessibilityLabel)
        .setAccessibilityCurrentState('page', isSelected)
        .allowKeyboardFocus()
        .listen('click', openScene)
        .access((self) => self.registerKeyboardShortcuts({
        key: ' ',
        action: () => self.click(),
    }, {
        key: 'Enter',
        action: () => self.click(),
    }, {
        key: 'ArrowRight',
        action: () => self.click(),
    }));
}
exports.NavigationLink = NavigationLink;
function TabView(...configuration) {
    const visibleTabIndex = new State(0);
    return VStack(HStack(ButtonGroup(...configuration.map((tab, i) => Button({
        iconName: tab.iconName,
        text: tab.text,
        accessibilityLabel: tab.text,
        action: () => (visibleTabIndex.value = i),
    }).access((self) => {
        const isPressed = new ComputedState({
            statesToBind: [visibleTabIndex],
            initialValue: false,
            compute(self) {
                self.value = visibleTabIndex.value == i;
            },
        });
        return self
            .setAccessibilityRole('link')
            .setAccessibilityCurrentState('page', isPressed)
            .addToClassConditionally('buttons-pressed', isPressed);
    }))).setAccessibilityRole('navigation')).cssFlex(0), Div(...configuration.map((tab, i) => tab.view
        .setVisibleIfMatch(i, visibleTabIndex)
        .setAccessibilityLabel(tab.text)
        .allowKeyboardFocus()
        .focusOnChange(visibleTabIndex, i)))).addToClass('tab-views');
}
exports.TabView = TabView;
